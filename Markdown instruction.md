# Инструкция работы с Markdown 

## Выделение текста

## Списки

<<<<<<< HEAD
<

## Работа с изображениями В Markdown существует 2 способа вставки изображений в документ:



a.  С помощью непосредственного указания URL-адреса изображения. Синтаксис данной команды выглядит следующим образом:
## Работа с изображениями 
В Markdown существует 2 способа вставки изображений в документ:

git 
=======
## Работа с изображениями 
В Markdown существует 2 способа вставки изображений в документ:


a. С помощью непосредственного указания URL-адреса изображения. Синтаксис данной команды выглядит следующим образом:

![Альтернативный текст](/путь/к/изображению.jpg)
или

![Альтернативный текст](/путь/к/изображению.jpg "Подсказка")
Иными словами, он состоит из следующих элементов:

восклицательный знак;
квадратные скобки, в которых указывается альтернативный изображению текст (он станет содержимым атрибута в элементе img);
круглые скобки, содержащие URL-адрес или относительный путь изображения, а также (необязательно) всплывающую подсказку, заключённуе в двойные или одиночные кавычки.
b. С помощью метки-идентификатора. Синтаксис данной команды записывается следующим образом:

![Альтернативный текст][id]
где «id» — имя определённой метки изображения. Метки изображений определяются при помощи синтаксиса, совершенно идентичного меткам гиперссылок:

[id]: путь/к/изображению "Необязательная подсказка"
Важной особенностью является то, что Markdown не позволяет задать размеры изображения (ширину, высоту).
<<<<<<< HEAD
<<<<<<< HEAD

## Ссылки и Картинки  

 то встроенная ссылка с title элементом. Это — без title.

А вот пример нескольких ссылок с разметкой как у сносок. Прокатит и короткая запись без указания id.

Вынос длинных урлов из предложения способствует сохранению читабельности исходника. Сноски можно располагать в любом месте документа.
Чтобы поставить гиперссылку без анкора, нужно взять URL в угловые скобки. С e-mail – аналогично.

Если вставлять с анкором, то тогда текст ссылки заключается в квадратные скобки, а адрес страницы – в круглые. Рядом с URL можно прописать тайтл, его объявляют в кавычках (он тоже остается внутри круглых скобок).

Это [ссылка]( "Агентство TexTerra") с тайтлом.

[Эта ссылка](http://example.net/) без заголовка.

<https://texterra.ru/&gt; – а это безанкорная ссылка.

Синтаксис разметки Markdown
Чтобы длинные URL не затрудняли чтение и написание документа Markdown, есть вариант присвоения каждой ссылке определенных ID (меток/переменных). Можно сделать это несколькими способами:

Ссылаемся на [блог TexTerra][tt-blog-link] через ID. Объявляем метку позже по аналогии со сносками. Цифрами обозначить тоже можно: [Google][1], [Yandex][2]

Еще можно так встраивать ссылки: [TexTerra] []

[tt-blog-link]: /blog "Блог про интернет-маркетинг"

[1]: google.com 'Сайт Google'

[2]: yandex.ru (Сайт «Яндекса»)

[TexTerra]:

Синтаксис разметки Markdown
Если URL длинные, да еще и с UTM-метками, их лучше спрятать в самый конец документа. Обратите внимание: тайтлы можно обозначить и двойными, и одинарными кавычками, а также в скобкахСинтаксис Markdown для работы с картинками очень похожий. Разница в восклицательном знаке перед первыми квадратными скобками. Ссылке на картинку тоже можно присвоить определенный ID. Примеры:

![Лого TexTerra](/upload/firmenniy-stil/footer-logo-svg.svg)

---

![Лого TexTerra](/upload/firmenniy-stil/footer-logo-svg.svg "Наш логотип")

---

![Картинка][logo]

[logo]: /upload/firmenniy-stil/footer-logo-svg.svg "Наш логотип"
=======
>>>>>>> links
=======
>>>>>>> links

## Работа с таблицами

## Цитаты

## Заключение

Ветвление Git - ветви в двух словах
Почти каждый VCS имеет некоторую форму поддержки ветвления. Ветвление означает, что вы отклоняетесь от основной линии разработки и продолжаете выполнять работу, не вмешиваясь в эту основную линию. Во многих инструментах VCS это довольно дорогостоящий процесс, часто требующий создания новой копии каталога исходного кода, что может занять много времени для крупных проектов.

Некоторые люди называют модель ветвления Git “убойной особенностью”, и это, безусловно, выделяет Git в сообществе VCS. Почему он такой особенный? Способ ветвления Git невероятно легкий, что позволяет выполнять операции ветвления почти мгновенно и переключаться между ветвями обычно так же быстро. В отличие от многих других VCS, Git поощряет рабочие процессы, которые часто ветвятся и объединяются, даже несколько раз в день. Понимание и освоение этой функции дает вам мощный и уникальный инструмент и может полностью изменить способ разработки.

Ветви в двух словах
Чтобы действительно понять, как Git выполняет ветвление, нам нужно сделать шаг назад и изучить, как Git хранит свои данные.

Как вы, возможно, помните из What is Git?, Git хранит данные не в виде серии наборов изменений или различий, а в виде серии снимков.

Когда вы делаете коммит, Git сохраняет объект коммита, который содержит указатель на снимок содержимого, которое вы создали. Этот объект также содержит имя и адрес электронной почты автора, введенное вами сообщение и указатели на коммит или коммиты, которые непосредственно предшествовали этому коммиту (его родительский элемент или родители): ноль родителей для первоначального коммита, один родитель для обычного коммита и несколько родителей для коммита, который приводитот слияния двух или более ветвей.

Чтобы визуализировать это, давайте предположим, что у вас есть каталог, содержащий три файла, и вы размещаете их все и фиксируете. При обработке файлов вычисляется контрольная сумма для каждого из них (хэш SHA-1, который мы упоминали в What is Git?), Сохраняется эта версия файла в репозитории Git (Git ссылается на них как на большие двоичные объекты) и добавляет эту контрольную сумму в промежуточную область:

$ git add README test.rb LICENSE
$ git commit -m 'Initial commit'
Когда вы создаете коммит с помощью запускаgit commit, Git проверяет каждую подкаталог (в данном случае только корневую директорию проекта) и сохраняет их как древовидный объект в репозитории Git. Затем Git создает объект фиксации, который содержит метаданные и указатель на корневое дерево проекта, чтобы он мог повторно создать этот снимок, когда это необходимо.

Теперь ваш репозиторий Git содержит пять объектов: три больших двоичных объекта (каждый из которых представляет содержимое одного из трех файлов), одно дерево, в котором перечислено содержимое каталога и указано, какие имена файлов хранятся в виде каких больших двоичных объектов, и один коммит с указателем на это корневое дерево и все метаданные коммита.

Ветвь в Git - это просто легкий подвижный указатель на один из этих коммитов. Имя ветви по умолчанию в Git - master. Когда вы начинаете делать коммиты, вам выдается masterветка, указывающая на последний сделанный вами коммит. Каждый раз, когда вы фиксируете, указатель masterветви автоматически перемещается вперед.

Ветвь “master” в Git не является специальной ветвью. Это точно так же, как и любая другая ветвь. Единственная причина, по которой почти в каждом репозитории есть один, заключается в том, что git initкоманда создает его по умолчанию, и большинство людей не утруждают себя его изменением.


Создание новой ветки
Что происходит, когда вы создаете новую ветку? Ну, это создает новый указатель для перемещения. Допустим, вы хотите создать новую ветку под названием testing. Вы делаете это с git branchпомощью команды:

 git branch testing
Это создает новый указатель на тот же коммит, над которым вы сейчас работаете.

Как Git узнает, в какой ветке вы сейчас находитесь? Он сохраняет специальный вызываемый указатель HEAD. Обратите внимание, что это сильно отличается от концепции HEADв других VCS, к которым вы можете привыкнуть, таких как Subversion или CVS. В Git это указатель на локальную ветку, в которой вы находитесь в данный момент. В этом случае вы все еще продолжаете master. git branchКоманда только создала новую ветку — она не переключилась на эту ветку.

Вы можете легко убедиться в этом, выполнив простую git logкоманду, которая показывает, куда указывают указатели ветвей. Эта опция вызывается --decorate.

$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit
Вы можете увидеть ветви masterиtesting, которые находятся прямо рядом с f30abфиксацией.

Переключение ветвей
Чтобы переключиться на существующую ветку, вы выполняете git checkoutкоманду. Давайте переключимся на новую testingветку:

 git checkout testing
Это перемещаетсяHEAD, чтобы указать на testingветку.

В чем смысл этого? Что ж, давайте сделаем еще один коммит:

 vim test.rb
 git commit -a -m 'made a change'

 Это интересно, потому что теперь ваша testingветка продвинулась вперед, но ваша masterветка по-прежнему указывает на коммит, на котором вы находились, когда бежалиgit checkout, чтобы переключить ветки. Давайте вернемся к masterветке:

$ git checkout master
Примечание
git log не показывает все ветви все время
Если бы вы запустили git logпрямо сейчас, вы могли бы задаться вопросом, куда делась только что созданная вами ветка "тестирование", поскольку она не будет отображаться в выходных данных.

Ветка не исчезла; Git просто не знает, что вы заинтересованы в этой ветке, и пытается показать вам, что, по его мнению, вас интересует. Другими словами, по умолчанию git logбудет отображаться только история коммитов под веткой, которую вы проверили.

Чтобы показать историю фиксации для нужной ветки, вы должны явно указать ее : git log testing. Чтобы показать все ветви, добавьте --all в свою git log команду.
Эта команда сделала две вещи. Он переместил указатель заголовка обратно, чтобы указать на masterветку, и вернул файлы в вашем рабочем каталоге обратно в снимок, на который masterуказывает. Это также означает, что изменения, которые вы вносите с этого момента, будут отличаться от более старой версии проекта. Это, по сути, перематывает работу, которую вы проделали в своей testingветке, чтобы вы могли двигаться в другом направлении.

Примечание
Переключение ветвей изменяет файлы в вашем рабочем каталоге
Важно отметить, что при переключении ветвей в Git файлы в вашем рабочем каталоге будут меняться. Если вы переключитесь на более старую ветку, ваш рабочий каталог будет выглядеть так, как он выглядел в последний раз, когда вы выполняли коммит в этой ветке. Если Git не может сделать это чисто, он вообще не позволит вам переключаться.

Давайте внесем несколько изменений и снова зафиксируем:

 vim test.rb
 git commit -a -m 'made other changes'
Теперь история вашего проекта разошлась (см. раздел Расходящаяся история). Вы создали и переключились на ветку, немного поработали над ней, а затем снова переключились на свою основную ветку и выполнили другую работу. Оба этих изменения изолированы в отдельных ветвях: вы можете переключаться между ветвями и объединять их вместе, когда будете готовы. И вы сделали все это с помощью простых branchкоманд , checkout, и commit.

Вы также можете легко увидеть это с git logпомощью команды. Если вы запустите git log --oneline --decorate --graph --allего, он распечатает историю ваших коммитов, показывая, где находятся ваши указатели на ветви и как ваша история разошлась.

$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) Made other changes
| * 87ab2 (testing) Made a change
|/
* f30ab Add feature #32 - ability to add new formats to the central interface
* 34ac2 Fix bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
Поскольку ветвь в Git на самом деле представляет собой простой файл, содержащий 40-символьную контрольную сумму SHA-1 коммита, на который он указывает, создание и уничтожение ветвей обходятся дешево. Создание новой ветки так же быстро и просто, как запись 41 байта в файл (40 символов и перевод строки).

Это резко контрастирует с тем, как ветвятся большинство старых инструментов VCS, которые включают копирование всех файлов проекта во второй каталог. Это может занять несколько секунд или даже минут, в зависимости от размера проекта, тогда как в Git процесс всегда происходит мгновенно. Кроме того, поскольку мы записываем родительские элементы при фиксации, поиск подходящей базы слияния для слияния выполняется автоматически, и, как правило, это очень легко сделать. Эти функции помогают побудить разработчиков часто создавать и использовать ветки.

Давайте посмотрим, почему вы должны это сделать.

Примечание
Создание новой ветки и одновременное переключение на нее
Обычно создается новая ветка и одновременно требуется переключиться на эту новую ветку — это можно сделать за одну операцию с git checkout -b <newbranchname>помощью .

Примечание
Начиная с версии Git 2.23, вы можете использовать git switchвместоgit checkout:

Переключитесь на существующую ветку : git switch testing-branch.

Создайте новую ветку и переключитесь на нее : git switch -c new-branch. -cФлаг означает create, вы также можете использовать полный флаг: --create.

Вернитесь к ранее проверенной ветке : git switch -.